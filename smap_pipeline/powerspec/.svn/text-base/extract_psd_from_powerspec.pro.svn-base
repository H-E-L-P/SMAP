;+
;NAME
; extract_psd_from_powerspec
;PURPOSE
; Extracts a specified power spectrum from the structure returned
; by read_powerspec.
;USAGE
; psd = extract_psd_from_powerspec( spec, detname )
;INPUTS
; spec         Structure containing power spec generated by read_powerspec
; detname      The detector or combination of detectors PSDs are
;               desired for.  Can be a vector.
;RETURNS
; An anonymous structure containing the PSD, or NaN if any of the specified
; dets are not found.  If the requested detector doesn't have a
; successfully calculated PSD, then the .bad member will be set for
; that PSD.
;OPTIONAL OUTPUTS
;  success       1 on success, 0 on failure
;  errmsg        An error message in case of failure
;KEYWORDS
;  verbose       Run in verbose mode
;MODIFICATION HISTORY
; Author: Alex Conley, May 2009
;-

FUNCTION extract_psd_from_powerspec, spec, detname, $
                                     SUCCESS=success, ERRMSG=errmsg,$
                                     VERBOSE=verbose
  COMPILE_OPT IDL2, STRICTARRSUBS
  success = 0b
  errmsg = ''
  
  IF ~ (SIZE(spec,/TNAME) EQ 'STRUCT') THEN BEGIN
     errmsg = "Input spec is not a stucture"
     IF KEYWORD_SET(verbose) THEN MESSAGE,errmsg,/INF
     RETURN,!VALUES.F_NAN
  ENDIF

  ;;Make sure we have all the tag names we need
  ;;Types are not checked
  tagsrequired = ['TYPE','NFREQ','CHUNKSIZE','WINDOWING',$
                  'WINDOWTYPE','OVERLAPPING','POLYREMOVE',$
                  'POLYORDER','BADMASK','DETNAMES',$
                  'FREQ','FREQUNITS','PSDS','PSD_UNITS','BAD',$
                  'NFILES','FILES','FILEMASK','NFILES_PER_PSD',$
                  'MINDATALENGTH']
  wpresent = WHERE_ARRAY( tagsrequired, TAG_NAMES(spec), npresent )
  IF npresent NE N_ELEMENTS(tagsrequired) THEN BEGIN
     wmissing = MISSING( TAG_NAMES(spec), tagsrequired )
     errmsg = "Some tags are missing from input struct: " + $
              STRJOIN( tagsrequired[wmissing],", ")
     IF KEYWORD_SET(verbose) THEN MESSAGE,errmsg,/INF
     RETURN,!VALUES.F_NAN
  ENDIF

  ndet = N_ELEMENTS(detname)
  IF ndet EQ 0 THEN BEGIN
     errmsg = "No detectors requested"
     IF KEYWORD_SET(verbose) THEN MESSAGE,errmsg,/INF
     RETURN,!VALUES.F_NAN
  ENDIF
  scalardet = ( SIZE(detname) )[0] EQ 0

  ;;If cross-spectra, make sure name is in right order internally
  spl = STRSPLIT( detname[0],'_' )
  IF N_ELEMENTS(spl) EQ 3 THEN BEGIN
     IF spec.type NE 'cross' THEN BEGIN
        errmsg = "Asked for cross-spectra type name from non-cross spectra"
        IF KEYWORD_SET(verbose) THEN MESSAGE,errmsg,/INF
        RETURN,!VALUES.F_NAN
     ENDIF
     int_detnames = STRARR( ndet )
     FOR i = 0, ndet-1 DO BEGIN
        spl = STRSPLIT( detname[i], '_', /EXTRACT )
        IF spl[1] LT spl[2] THEN $
           int_detnames[i] = spl[0]+'_'+spl[1]+'_'+spl[2] ELSE $
              int_detnames[i] = spl[0]+'_'+spl[2]+'_'+spl[1]
     ENDFOR
  ENDIF ELSE int_detnames = detname

  IF ndet EQ 1 THEN BEGIN
     loc = WHERE( spec.detnames EQ int_detnames[0], nfound )
     IF nfound NE 1 THEN BEGIN
        IF nfound EQ 0 THEN errmsg="Detector "+detname[0]+" not found" 
        IF nfound GT 1 THEN errmsg="Detector "+detname[0]+" not unique in spec"
        IF KEYWORD_SET(verbose) THEN MESSAGE,errmsg,/INF
        RETURN,!VALUES.F_NAN
     ENDIF
  ENDIF ELSE BEGIN
     ;;Now faster to use binary search
     loc = VALUE_LOCATE( spec.detnames[spec.detidx], int_detnames )
     loc = spec.detidx[loc]
     ;;Now see if it actually found them
     ;;Don't do a uniqueness test, as value_locate doesn't handle that
     wbad = WHERE( spec.detnames[loc] NE int_detnames, nbad )
     IF nbad NE 0 THEN BEGIN
        errmsg = "Detector(s) "+STRJOIN(detname[wbad],", ")+" not found in spec"
        IF KEYWORD_SET(verbose) THEN MESSAGE,errmsg,/INF
        RETURN,!VALUES.F_NAN
     ENDIF
  ENDELSE

  nfreq = spec.nfreq
  IF spec.nfiles LE 0 THEN BEGIN
     errmsg = "No file info in input spec"
     IF KEYWORD_SET(verbose) THEN MESSAGE,errmsg,/INF
     RETURN,!VALUES.F_NAN
  ENDIF
  retstruct = { type: spec.type, nfreq: nfreq, chunksize: spec.chunksize,$
                windowing: spec.windowing, windowtype: spec.windowtype,$
                ndatapoints: -1L, mindatalength: 0,$
                overlapping: spec.overlapping, polyremove: spec.polyremove,$
                polyorder: spec.polyorder, $
                badmask: spec.badmask, detname: '',$
                freq: spec.freq, frequnits: spec.frequnits,$
                psd: DBLARR(nfreq), psd_units: '', bad: 0b,$
                nfiles: spec.nfiles, files: spec.files,$
                filemask: ULONARR(spec.nfiles), nfiles_used: 0 }

  IF scalardet THEN BEGIN
     retval = retstruct
     retval.detname = detname
     retval.psd = spec.psds[loc,*]
     retval.psd_units = spec.psd_units[loc]
     retval.bad = spec.bad[loc]
     retval.filemask = spec.filemask[loc,*]
     retval.nfiles_used = spec.nfiles_per_psd[loc]
     retval.ndatapoints = spec.ndatapoints
     retval.mindatalength = spec.mindatalength
  ENDIF ELSE BEGIN
     retval = REPLICATE(retstruct,ndet)
     FOR i=0,ndet-1 DO BEGIN
        retval[i].detname = detname[i]
        retval[i].psd = spec.psds[loc[i],*]
        retval[i].psd_units = spec.psd_units[loc[i]]
        retval[i].bad = spec.bad[loc[i]]
        retval[i].filemask = spec.filemask[loc[i],*]
        retval[i].nfiles_used = spec.nfiles_per_psd[loc[i]]
        retval[i].ndatapoints = spec.ndatapoints
        retval[i].mindatalength = spec.mindatalength
     ENDFOR
  ENDELSE

  success = 1b
  RETURN,retval

END
